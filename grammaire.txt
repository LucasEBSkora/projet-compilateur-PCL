<fichier>    ::= with Ada.Text_IO; use Ada.Text_IO ;
              procedure <ident> is <decl>*
              begin <instr>+ end <ident>? ; EOF
<decl>       ::= type <ident>;
              | type <ident> is access <ident> ;
              | type <ident> is record <champs>+ end record ;
              | <ident>+, : <type> (:= <expr>)? ; 
              | procedure <ident> <params>? is <decl>*
                begin <instr>+ end <ident>?;
              | function <ident> <params>? return <type> is <decl>*
                begin <instr>+ end <ident>?;
<champs>     ::= <ident>+, : <type>; 
<type>       ::= <ident>
              | access <ident>
<params>     ::= (<param>+;)
<param>      ::= <ident>+, : <mode>? <type>
<mode>       ::= in | in out


<instr>      ::= <accès> := <expr>;
              | <appel> ;
              | return <expr>? ;
              | begin <instr>+ end;
              | if <expr> then <instr>+ (elsif <expr> then <instr>+)*
                (else <instr>+)? end if ;
              | for <ident> in reverse? <expr> .. <expr>
                loop <instr>+ end loop ;
              | while <expr> loop <instr>+ end loop ;

<expr> ::= <and> ((or  | or else) <expr>)?
<and> ::= <not> ((and | and then) <and>)?
<not> ::= not <not>
      |  <egal>
<egal> ::= <comparaison> (( = | \=) <comparaison>)?
<comparaison> ::= <addition> (( > |  >= | < | <=) <addition>)?
<addition> ::= <multiplication> ((+ | -) <addition>)?
<multiplication> ::= <negation> ((* | \ | rem) <multiplication>)?
<negation> ::= - <negation>
            |  <accès_ou_appel>
<accès>      ::= <primaire> 
              | <primaire> . <ident>
<primaire>       ::= <entier> | <caractere> | true | false | null
                  | ( <expr> )
                  | new <ident>
                  | character'val(<expr>)
                  | <appel>

<appel> ::= <ident>
          | <ident> ( <expr>+, )
